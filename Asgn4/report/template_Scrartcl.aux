\relax 
\@writefile{toc}{\contentsline {section}{\numberline {1}Exercise 11: Cilk and OpenCL}{1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1}Advantages of Cilk and keywords needed}{1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.1.1}cilk\_spawn}{1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.1.2}cilk\_sync}{1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.1.3}cilk\_for}{2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.2}Array Expressions with Intel C language extensions}{3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.1}Array Section Notation}{3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {1.2.2}Types of expressions}{3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.3}Memory Structure in OpenCL}{5}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces Memory and Hardware Structure in OpenCL}}{5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.4}OpenCL Execution Model and Compilation of OpenCL Application}{7}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Exercise 12: Quicksort with Intel Cilk}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Code Overview}{8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Results and Analysis}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Speedup of Intel Cilk Plus implementation for three different problem sizes}}{8}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Strong scaling comparison for Intel Cilk and OpenMP implementations of quicksort. The vertical axis shows time elapsed in seconds and the horizontal axis the number of threads used}}{9}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Weak scaling comparison for Intel Cilk and OpenMP implementations of quicksort. The vertical axis shows time elapsed in seconds and the horizontal axis the number of threads spawned as well as the array length in million elements}}{10}}
\@writefile{toc}{\contentsline {section}{\numberline {3}Exercise 13: Laplace Equation with Intel Array Extensions}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Code Overview}{10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Results and Analysis}{11}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Performance comparison of the three laplace solver implemenations. Time elapsed is given in seconds and the x-axis denotes mesh width. The maximum number of iterations was set high enough so that it would not be reached during runtime and the accuracy was set in all cases to 0.0001}}{11}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Exercise 14: Matrix Multiplication with OpenCL}{12}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Overview}{12}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Algorithm}{12}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}Results and Analysis}{12}}
\@writefile{lof}{\contentsline {figure}{\numberline {6}{\ignorespaces \textbf  {Comparison of GFLOP/s achieved for Matrix Multiplication.} Blue line depicts performance using OpenCL, and Orange line depicts performance with OpenMP. We consider only time spent in executing the kernels.}}{13}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces \textbf  {Comparison of GFLOP/s achieved for Matrix Multiplication with overhead.} Blue line depicts performance using OpenCL, and Orange line depicts performance with OpenMP. Here, we consider the total time spent in compiling kernels, transferring input matrices to GPU, execution of kernels and reading output matrix from GPU.}}{14}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Exercise 15: Laplace Equation with OpenCL}{14}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}Code Overview}{14}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.2}Results and Analysis}{14}}
